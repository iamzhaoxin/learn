# mybatis druid jdbc 关系

jdbc整合了:加载数据库驱动,创建连接,写原生语句,执行,关闭这些东西.

mybatis是对jdbc的封装,他允许你通过配置的形式,配置数据库参数,并且允许你通过xml来写动态sql语句.
<if:test>让你可以把sql变得灵活起来.并且还能将你的查询结果直接映射到你想要的实体上面.

mybatis发现,在你每次访问都要重新创建创建连接,写,关.很麻烦,所以mybatis说,我可以接受你再配置一个连接池, 比如druid.

---
简单的访问流程: controller->service->dao->mapper

1. 首先项目启动时druid就已经使用jdbc创建好一堆连接了,留待后用.
2. 当请求到mapper时,mybatis框架创建临时类.
3. 然后将动态sql进行替换重写,变成原始的native sql.
4. 从druid拿到一个连接.
5. 将sql通过连接交给数据库执行.
6. 然后获取执行结果.
7. mybatis进行将结果进行映射,返回数据.

# SSM项目实现方案

- 实体类开发: 使用Lombok快速制作
- Dao: 整合MybatisPlus, 数据层测试类
- Service: 基于MP增量开发, 业务层测试类
- Controller: 基于Restful, 测试接口
- Controller: 前后端开发协议制作
- 页面: VUE+ElementUI
    - 列表/新增/修改/删除/分页/查询
- 项目异常处理

## 使用Lombok

```xml

<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
</dependency>
```

## Mybatis Plus


```xml
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.5.1</version>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
            <version>1.2.8</version>
        </dependency>
```


### 实体类的映射

- 如果数据库表是标准的*下划线命名*,能自动对应实体类的名称(user_info自动对应UserInfo类)
- 如果数据库表都有共同前缀,可以添加配置`mybatis-plus.global-config.db-config.table-prefix=t_`
- 添加配置`mybatis-plus.global-config.db-config.table-underline=false`表示数据库表不使用下划线命名(userinfo表对应UserInfo类)
- 在实体类用@TableName表明注解指定当前实体类对应的表名,变量使用@Tabled主键注解和@TableField注解指定字段名

### 分页

1. 使用Page封装分页数据(`Page实现类` 实现了 `接口IPage`)
2. 分页操作依赖`分页拦截器`

### 日志

在`mybatis-plus.configuration.log-impl`设置为`org.apache.ibatis.logging.stdout.StdOutImpl`是将日志打印到控制台

### 条件查询

- 推荐使用`LambdaQueryWrapper`封装
- `lambdaQueryWrapper.like(动态条件,User::getXxx,likedValue)`

### MybatisPlus的增强Service

```java

@Service
public class IUserService extends ServiceImpl<UserDao, User> {

}
```

- MybatisPlus提供了
    - 业务层通用接口`IService<T>`
    - 业务层通用实现类`ServiceImpl<M,T>`
- 在通用类的基础上做*功能重载*或*增加*
- 重载时尽量不要覆盖原有操作,避免原始功能的丢失

## Controller层

```java

@RestController
@RequestMapping("/users")
public class UserController {
    
    //...

    @GetMapping
    public List<User> getAll() {
        return iUserService.list();
    }

    @PostMapping
    // notice @RequestBody用于接收json数据, @RequestParam接收application/x-www-form-urlencoded键值对参数
    public Boolean save(@RequestBody User user) {
        return iUserService.save(user);
    }

    //http://localhost:80/1
    // notice Mapping加上{id} 接收参数时加上@PathVariable从路径中接收参数
    @GetMapping("{id}")
    public User getById(@PathVariable Integer id) {
        System.out.println("getting by id: " + id);
        return iUserService.getById(id);
    }
}
```

## 表现层消息一致性处理

- 设计表现层返回结果的*模型类*, 用于前后端数据格式的统一,也称为**前后端数据协议**

```java
import lombok.Data;

@Data
public class R {
    private Boolean flag;
    private Object data;
}
```

```java

@RestController
@RequestMapping("/users")
public class UserController {
    
    //...
  
    @GetMapping("{currentPage}/{pageSize}")
    public R getById(@PathVariable Integer currentPage, @PathVariable Integer pageSize) {
        return new R(true, iUserService.getPage(currentPage, pageSize));
    }
}
```

## 前后端协议联调
- 前后端分离设计中,页面归属前端服务器
- 单体工程中,页面放在resources目录下的static目录中,(遇到bug先执行clean试试)

## 项目异常处理
```java
@RestControllerAdvice   //作为SpringMVC的异常处理器
public class ExceptionAdvice {
    
    @ExceptionHandler   //拦截所有异常
    public R doException(Exception ex){
        //记录日志.通知运维.通知开发
        return new R(false,"error");
    }
}
```
