{"remainingRequest":"D:\\activiti\\project01\\jeecg-boot-activiti-master\\ant-design-vue-jeecg\\node_modules\\babel-loader\\lib\\index.js!D:\\activiti\\project01\\jeecg-boot-activiti-master\\ant-design-vue-jeecg\\node_modules\\@vue\\cli-plugin-eslint\\node_modules\\eslint-loader\\index.js??ref--13-0!D:\\activiti\\project01\\jeecg-boot-activiti-master\\ant-design-vue-jeecg\\src\\components\\jeecg\\dynamic\\cm_hint.js","dependencies":[{"path":"D:\\activiti\\project01\\jeecg-boot-activiti-master\\ant-design-vue-jeecg\\src\\components\\jeecg\\dynamic\\cm_hint.js","mtime":1611914356000},{"path":"D:\\activiti\\project01\\jeecg-boot-activiti-master\\ant-design-vue-jeecg\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1621061384845},{"path":"D:\\activiti\\project01\\jeecg-boot-activiti-master\\ant-design-vue-jeecg\\node_modules\\babel-loader\\lib\\index.js","mtime":1621061377995},{"path":"D:\\activiti\\project01\\jeecg-boot-activiti-master\\ant-design-vue-jeecg\\node_modules\\@vue\\cli-plugin-eslint\\node_modules\\eslint-loader\\index.js","mtime":1617935819779}],"contextDependencies":[],"result":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\nimport { js_keyword, js_method } from './Resource';\n\n(function (mod) {\n  mod(CodeMirror);\n  /*if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env*/\n})(function (CodeMirror) {\n  var Pos = CodeMirror.Pos;\n\n  function forEach(arr, f) {\n    for (var i = 0, e = arr.length; i < e; ++i) {\n      f(arr[i]);\n    }\n  }\n\n  function arrayContains(arr, item) {\n    if (!Array.prototype.indexOf) {\n      var i = arr.length;\n\n      while (i--) {\n        if (arr[i] === item) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    return arr.indexOf(item) != -1;\n  }\n\n  function scriptHint(editor, keywords, getToken, options) {\n    // Find the token at the cursor\n    var cur = editor.getCursor(),\n        token = getToken(editor, cur);\n    if (/\\b(?:string|comment)\\b/.test(token.type)) return;\n    var innerMode = CodeMirror.innerMode(editor.getMode(), token.state);\n    if (innerMode.mode.helperType === \"json\") return;\n    token.state = innerMode.state;\n\n    if ('.' === token.string) {\n      var arr = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = js_method[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var k = _step.value;\n          arr.push(k);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return {\n        list: arr,\n        from: Pos(cur.line, token.start),\n        to: Pos(cur.line, token.end)\n      };\n    } // If it's not a 'word-style' token, ignore the token.\n\n\n    if (!/^[\\w$_]*$/.test(token.string)) {\n      token = {\n        start: cur.ch,\n        end: cur.ch,\n        string: \"\",\n        state: token.state,\n        type: token.string == \".\" ? \"property\" : null\n      };\n    } else if (token.end > cur.ch) {\n      token.end = cur.ch;\n      token.string = token.string.slice(0, cur.ch - token.start);\n    }\n\n    var tprop = token; // If it is a property, find out what it is a property of.\n\n    while (tprop.type == \"property\") {\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (tprop.string != \".\") return;\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (!context) var context = [];\n      context.push(tprop);\n    }\n\n    return {\n      list: getCompletions(token, context, keywords, options),\n      from: Pos(cur.line, token.start),\n      to: Pos(cur.line, token.end)\n    };\n  }\n\n  function javascriptHint(editor, options) {\n    return scriptHint(editor, javascriptKeywords, function (e, cur) {\n      return e.getTokenAt(cur);\n    }, options);\n  }\n\n  ;\n  CodeMirror.registerHelper(\"hint\", \"javascript\", javascriptHint);\n\n  function getCoffeeScriptToken(editor, cur) {\n    // This getToken, it is for coffeescript, imitates the behavior of\n    // getTokenAt method in javascript.js, that is, returning \"property\"\n    // type and treat \".\" as indepenent token.\n    var token = editor.getTokenAt(cur);\n\n    if (cur.ch == token.start + 1 && token.string.charAt(0) == '.') {\n      token.end = token.start;\n      token.string = '.';\n      token.type = \"property\";\n    } else if (/^\\.[\\w$_]*$/.test(token.string)) {\n      token.type = \"property\";\n      token.start++;\n      token.string = token.string.replace(/\\./, '');\n    }\n\n    return token;\n  }\n\n  function coffeescriptHint(editor, options) {\n    return scriptHint(editor, coffeescriptKeywords, getCoffeeScriptToken, options);\n  }\n\n  CodeMirror.registerHelper(\"hint\", \"coffeescript\", coffeescriptHint);\n  var stringProps = (\"charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight \" + \"toUpperCase toLowerCase split concat match replace search\").split(\" \");\n  var arrayProps = (\"length concat join splice push pop shift unshift slice reverse sort indexOf \" + \"lastIndexOf every some filter forEach map reduce reduceRight \").split(\" \");\n  var funcProps = \"prototype apply call bind\".split(\" \");\n  var javascriptKeywords = (\"break case catch class const continue debugger default delete do else export extends false finally for function \" + \"if in import instanceof new null return super switch this throw true try typeof var void while with yield that\").split(\" \");\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = js_keyword[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var jk = _step2.value;\n      javascriptKeywords.push(jk);\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  var coffeescriptKeywords = (\"and break catch class continue delete do else extends false finally for \" + \"if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes\").split(\" \");\n\n  function forAllProps(obj, callback) {\n    if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {\n      for (var name in obj) {\n        callback(name);\n      }\n    } else {\n      for (var o = obj; o; o = Object.getPrototypeOf(o)) {\n        Object.getOwnPropertyNames(o).forEach(callback);\n      }\n    }\n  }\n\n  function getCompletions(token, context, keywords, options) {\n    var found = [],\n        start = token.string,\n        global = options && options.globalScope || window;\n\n    function maybeAdd(str) {\n      if (str.lastIndexOf(start, 0) == 0 && !arrayContains(found, str)) found.push(str);\n    }\n\n    function gatherCompletions(obj) {\n      if (typeof obj == \"string\") forEach(stringProps, maybeAdd);else if (obj instanceof Array) forEach(arrayProps, maybeAdd);else if (obj instanceof Function) forEach(funcProps, maybeAdd);\n      forAllProps(obj, maybeAdd);\n    }\n\n    if (context && context.length) {\n      // If this is a property, see if it belongs to some object we can\n      // find in the current environment.\n      var obj = context.pop(),\n          base;\n\n      if (obj.type && obj.type.indexOf(\"variable\") === 0) {\n        if (options && options.additionalContext) base = options.additionalContext[obj.string];\n        if (!options || options.useGlobalScope !== false) base = base || global[obj.string];\n      } else if (obj.type == \"string\") {\n        base = \"\";\n      } else if (obj.type == \"atom\") {\n        base = 1;\n      } else if (obj.type == \"function\") {\n        if (global.jQuery != null && (obj.string == '$' || obj.string == 'jQuery') && typeof global.jQuery == 'function') base = global.jQuery();else if (global._ != null && obj.string == '_' && typeof global._ == 'function') base = global._();\n      }\n\n      while (base != null && context.length) {\n        base = base[context.pop().string];\n      }\n\n      if (base != null) gatherCompletions(base);\n    } else {\n      // If not, just look in the global object, any local scope, and optional additional-context\n      // (reading into JS mode internals to get at the local and global variables)\n      for (var v = token.state.localVars; v; v = v.next) {\n        maybeAdd(v.name);\n      }\n\n      for (var c = token.state.context; c; c = c.prev) {\n        for (var v = c.vars; v; v = v.next) {\n          maybeAdd(v.name);\n        }\n      }\n\n      for (var v = token.state.globalVars; v; v = v.next) {\n        maybeAdd(v.name);\n      }\n\n      if (options && options.additionalContext != null) for (var key in options.additionalContext) {\n        maybeAdd(key);\n      }\n      if (!options || options.useGlobalScope !== false) gatherCompletions(global);\n      forEach(keywords, maybeAdd);\n    }\n\n    return found;\n  }\n});",{"version":3,"sources":["D:/activiti/project01/jeecg-boot-activiti-master/ant-design-vue-jeecg/src/components/jeecg/dynamic/cm_hint.js"],"names":["js_keyword","js_method","mod","CodeMirror","Pos","forEach","arr","f","i","e","length","arrayContains","item","Array","prototype","indexOf","scriptHint","editor","keywords","getToken","options","cur","getCursor","token","test","type","innerMode","getMode","state","mode","helperType","string","k","push","list","from","line","start","to","end","ch","slice","tprop","context","getCompletions","javascriptHint","javascriptKeywords","getTokenAt","registerHelper","getCoffeeScriptToken","charAt","replace","coffeescriptHint","coffeescriptKeywords","stringProps","split","arrayProps","funcProps","jk","forAllProps","obj","callback","Object","getOwnPropertyNames","getPrototypeOf","name","o","found","global","globalScope","window","maybeAdd","str","lastIndexOf","gatherCompletions","Function","pop","base","additionalContext","useGlobalScope","jQuery","_","v","localVars","next","c","prev","vars","globalVars","key"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\nimport { js_keyword, js_method } from './Resource'\n(function(mod) {\n  mod(CodeMirror);\n  /*if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env*/\n\n})(function(CodeMirror) {\n  var Pos = CodeMirror.Pos;\n\n  function forEach(arr, f) {\n    for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);\n  }\n\n  function arrayContains(arr, item) {\n    if (!Array.prototype.indexOf) {\n      var i = arr.length;\n      while (i--) {\n        if (arr[i] === item) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return arr.indexOf(item) != -1;\n  }\n\n  function scriptHint(editor, keywords, getToken, options) {\n    // Find the token at the cursor\n    var cur = editor.getCursor(), token = getToken(editor, cur);\n    if (/\\b(?:string|comment)\\b/.test(token.type)) return;\n    var innerMode = CodeMirror.innerMode(editor.getMode(), token.state);\n    if (innerMode.mode.helperType === \"json\") return;\n    token.state = innerMode.state;\n    if('.' === token.string){\n      let arr = []\n      for(let k of js_method){\n        arr.push(k)\n      }\n      return {\n        list: arr,\n        from: Pos(cur.line, token.start),\n        to: Pos(cur.line, token.end)\n      };\n    }\n    // If it's not a 'word-style' token, ignore the token.\n    if (!/^[\\w$_]*$/.test(token.string)) {\n      token = {start: cur.ch, end: cur.ch, string: \"\", state: token.state,\n        type: token.string == \".\" ? \"property\" : null};\n    } else if (token.end > cur.ch) {\n      token.end = cur.ch;\n      token.string = token.string.slice(0, cur.ch - token.start);\n    }\n\n    var tprop = token;\n    // If it is a property, find out what it is a property of.\n    while (tprop.type == \"property\") {\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (tprop.string != \".\") return;\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (!context) var context = [];\n      context.push(tprop);\n    }\n    return {list: getCompletions(token, context, keywords, options),\n      from: Pos(cur.line, token.start),\n      to: Pos(cur.line, token.end)};\n  }\n\n  function javascriptHint(editor, options) {\n    return scriptHint(editor, javascriptKeywords,\n      function (e, cur) {return e.getTokenAt(cur);},\n      options);\n  };\n  CodeMirror.registerHelper(\"hint\", \"javascript\", javascriptHint);\n\n  function getCoffeeScriptToken(editor, cur) {\n    // This getToken, it is for coffeescript, imitates the behavior of\n    // getTokenAt method in javascript.js, that is, returning \"property\"\n    // type and treat \".\" as indepenent token.\n    var token = editor.getTokenAt(cur);\n    if (cur.ch == token.start + 1 && token.string.charAt(0) == '.') {\n      token.end = token.start;\n      token.string = '.';\n      token.type = \"property\";\n    }\n    else if (/^\\.[\\w$_]*$/.test(token.string)) {\n      token.type = \"property\";\n      token.start++;\n      token.string = token.string.replace(/\\./, '');\n    }\n    return token;\n  }\n\n  function coffeescriptHint(editor, options) {\n    return scriptHint(editor, coffeescriptKeywords, getCoffeeScriptToken, options);\n  }\n  CodeMirror.registerHelper(\"hint\", \"coffeescript\", coffeescriptHint);\n\n  var stringProps = (\"charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight \" +\n    \"toUpperCase toLowerCase split concat match replace search\").split(\" \");\n  var arrayProps = (\"length concat join splice push pop shift unshift slice reverse sort indexOf \" +\n    \"lastIndexOf every some filter forEach map reduce reduceRight \").split(\" \");\n  var funcProps = \"prototype apply call bind\".split(\" \");\n\n  var javascriptKeywords = (\"break case catch class const continue debugger default delete do else export extends false finally for function \" +\n    \"if in import instanceof new null return super switch this throw true try typeof var void while with yield that\").split(\" \");\n  for(let jk of js_keyword){\n    javascriptKeywords.push(jk)\n  }\n  var coffeescriptKeywords = (\"and break catch class continue delete do else extends false finally for \" +\n    \"if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes\").split(\" \");\n\n  function forAllProps(obj, callback) {\n    if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {\n      for (var name in obj) callback(name)\n    } else {\n      for (var o = obj; o; o = Object.getPrototypeOf(o))\n        Object.getOwnPropertyNames(o).forEach(callback)\n    }\n  }\n\n  function getCompletions(token, context, keywords, options) {\n    var found = [], start = token.string, global = options && options.globalScope || window;\n    function maybeAdd(str) {\n      if (str.lastIndexOf(start, 0) == 0 && !arrayContains(found, str)) found.push(str);\n    }\n    function gatherCompletions(obj) {\n      if (typeof obj == \"string\") forEach(stringProps, maybeAdd);\n      else if (obj instanceof Array) forEach(arrayProps, maybeAdd);\n      else if (obj instanceof Function) forEach(funcProps, maybeAdd);\n      forAllProps(obj, maybeAdd)\n    }\n\n    if (context && context.length) {\n      // If this is a property, see if it belongs to some object we can\n      // find in the current environment.\n      var obj = context.pop(), base;\n      if (obj.type && obj.type.indexOf(\"variable\") === 0) {\n        if (options && options.additionalContext)\n          base = options.additionalContext[obj.string];\n        if (!options || options.useGlobalScope !== false)\n          base = base || global[obj.string];\n      } else if (obj.type == \"string\") {\n        base = \"\";\n      } else if (obj.type == \"atom\") {\n        base = 1;\n      } else if (obj.type == \"function\") {\n        if (global.jQuery != null && (obj.string == '$' || obj.string == 'jQuery') &&\n          (typeof global.jQuery == 'function'))\n          base = global.jQuery();\n        else if (global._ != null && (obj.string == '_') && (typeof global._ == 'function'))\n          base = global._();\n      }\n      while (base != null && context.length)\n        base = base[context.pop().string];\n      if (base != null) gatherCompletions(base);\n    } else {\n      // If not, just look in the global object, any local scope, and optional additional-context\n      // (reading into JS mode internals to get at the local and global variables)\n      for (var v = token.state.localVars; v; v = v.next) maybeAdd(v.name);\n      for (var c = token.state.context; c; c = c.prev)\n        for (var v = c.vars; v; v = v.next) maybeAdd(v.name)\n      for (var v = token.state.globalVars; v; v = v.next) maybeAdd(v.name);\n      if (options && options.additionalContext != null)\n        for (var key in options.additionalContext)\n          maybeAdd(key);\n      if (!options || options.useGlobalScope !== false)\n        gatherCompletions(global);\n      forEach(keywords, maybeAdd);\n    }\n    return found;\n  }\n});"]}]}